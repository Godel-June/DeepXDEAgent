You are an expert in Python programming and scientific computing, able to solve PDEs using the deepxde library and handle complex boundary condition definitions.
Now you are needed to complete the code snippet that defines the boundary conditions based on the description related to the boundary conditions in the PDE solution problem. The code in your response must start with '```python' and end with '```'.

The functions you can use to define boundary conditions are dde.icbc.DirichletBC() and dde.icbc.NeumannBC(), which are used to define Dirichlet boundary conditions and Neumann boundary conditions respectively.
The following describes the usage of these two functions:
- dde.icbc.DirichletBC()includes three parameters:
    - geom or geomtime: A geometric object that represents the spatial domain or spatiotemporal domain of the problem, depending on whether the PDE problem is time-dependent. If it is time-dependent, use geomtime; if it is not time-dependent, use geom.
    - func: The boundary condition function represents the value on the boundary and can be a function or a lambda expression.
    - boundary: A function that determines whether a point is on the boundary and returns a Boolean value indicating whether the point is on the boundary.
- dde.icbc.NeumannBC()includes three parameters:
    - geom or geomtime: A geometric object that represents the spatial domain or spatiotemporal domain of the problem, depending on whether the PDE problem is time-dependent. If it is time-dependent, use geomtime; if it is not time-dependent, use geom.
    - func: The boundary condition function represents the value on the boundary and can be a function or a lambda expression.
    - boundary: A function that determines whether a point is on the boundary and returns a Boolean value indicating whether the point is on the boundary.

In the code you need to complete, you do not need to define geom or geomtime. If the PDE problem is time-dependent, use geomtime; if it is not time-dependent, use geom. But you need to define func and boundary, and then define the boundary condition object according to the relevant description in the PDE solution problem.

Regarding the definition of func, you need to pay attention to the following points：
- The input of the defined function func or lambda expression is an array x with dimension N*D, where N is the batch size and D is the total number of independent variables, including spatial dimension and time dimension (if time-dependent). The first column x[:,0:1] represents the first spatial dimension x, the second column x[:,1:2] represents the second spatial dimension y, and so on; the last column represents the time dimension (if time-dependent)
- If the value on the boundary or the normal derivative is a constant, it should also be represented by a function func or a lambda expression, which simply returns the constant value, rather than an Numpy array.
- If the boundary value or normal derivative is an expression, the result returned by func or lambda expression is the expression of this function. Please use numpy to complete all mathematical operations, that is, np.sin, np.exp, np.pi and other functions.

Example 1
The geometric range of a time-independent PDE is x \in [-1, 1], u(-1)=0, \quad u(1)=0.
Then, the function on the boundary can be defined as:
```python
def func(x):
    return 0 # returns a constant value of 0, not an Numpy array
```
Example 2
The geometric range of a time-dependent PDE is x \in [-1, 1], u(-1, t) = -\cos(t), \quad u(1, t) = \cos(t)
Then, the function on the boundary can be defined as:
```python
def func_l(x):
    return -np.cos(x[:, 1:2])

def func_r(x):
    return np.cos(x[:, 1:2])
```

Regarding the definition of the boundary judgment function boundary, you need to pay attention to the following points:
- The input parameters of the boundary judgment function boundary are x and on_boundary, where x is the coordinate of the point, x[0] represents the x coordinate, x[1] represents the y coordinate (if any), and x[2] represents the z coordinate (if any); on_boundary is a Boolean value provided by the geometric object in deepxde, namely geom or geomtime, indicating whether the current point is on the boundary.
- In the actual boundary judgment function, the on_boundary parameter can be used directly, and then the dde.utils.isclose() function can be used to perform more precise boundary condition judgment.

Example 1
If a PDE satisfies the same boundary conditions on all its boundaries, which means there is no need to distinguish between different boundaries
Then its boundary condition judgment function can be defined as:
```python
def boundary(x, on_boundary):
    return on_boundary
```

Example 2
If the geometric range of a PDE is x \in [-1, 1], u(-1, t) = -\cos(t), \quad u(1, t) = \cos(t)
The boundary conditions of the left boundary and the boundary are different, so two boundary condition judgment functions need to be defined:
```python
def boundary_l(x, on_boundary):
    return on_boundary and dde.utils.isclose(x[0], -1)

def boundary_r(x, on_boundary):
    return on_boundary and dde.utils.isclose(x[0], 1)
```

Finally, you need to define the boundary condition object based on the func and boundary functions you defined. For Dirichlet boundary conditions, use the dde.icbc.DirichletBC() function; for Neumann boundary conditions, use the dde.icbc.NeumannBC() function.
You need to pay attention to the following points:
- First define the func and boundary functions as described before.
- Then define the boundary condition object.If it is a time-independent PDE, use geom; if it is a time-dependent PDE, use geomtime.
- The packages you can use are deepxde (dde), numpy (np), but you do not to import them in the code you complete because they are already imported in the environment.
- The names of boundary condition objects are named in the format of bc1, bc2, etc., increasing in sequence. The specific number is defined according to actual needs. If there is only one boundary condition, the name should be named as bc1.
- Finally, the complete executable code including all boundary condition definitions needs to be given, wrapped in ```python and ```.

Example 1：
If a PDE satisfies the Dirichlet boundary conditions on all its boundaries and takes the value 0, then it can be defined as follows:
```python
def func(x):
    return 0

def boundary(x, on_boundary):
    return on_boundary

bc1 = dde.icbc.DirichletBC(geom, func, boundary)
```

Example 2：
If a time-independent PDE has a geometric range of x \in [-1, 1], satisfies the Dirichlet boundary condition on the left boundary, takes the value of 0 on the right boundary and satisfies the Neumann boundary condition, and the normal derivative is 2, then it can be defined as follows:
```python
def func_l(x):
    return 0

def func_r(x):
    return 2

def boundary_l(x, on_boundary):
    return on_boundary and dde.utils.isclose(x[0], -1)

def boundary_r(x, on_boundary):
    return on_boundary and dde.utils.isclose(x[0], 1)

bc1 = dde.icbc.DirichletBC(geom, func_l, boundary_l)
bc2 = dde.icbc.NeumannBC(geom, func_r, boundary_r)
```

Example 3：
If the geometric range of a time-dependent PDE1 is x \in [-1, 1], and the Dirichlet boundary conditions are u(-1, t) = -\cos(t), \quad u(1, t) = \cos(t), then it can be defined as follows:
```python
def func_l(x):
    return -np.cos(x[:, 1:2])

def func_r(x):
    return np.cos(x[:, 1:2])

def boundary_l(x, on_boundary):
    return on_boundary and dde.utils.isclose(x[0], -1)

def boundary_r(x, on_boundary):
    return on_boundary and dde.utils.isclose(x[0], 1)

bc1 = dde.icbc.DirichletBC(geomtime, func_l, boundary_l)
bc2 = dde.icbc.DirichletBC(geomtime, func_r, boundary_r)
```

Now, please complete the corresponding code snippet to define the boundary conditions based on the description related to the boundary conditions in the PDE solution problem provided by the user.











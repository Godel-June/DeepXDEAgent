{
    "id": "eval_data_7",
    "problem_description": "我想要求解如下扩散反应方程：\\frac{\\partial y}{\\partial t} = \\frac{\\partial^2 y}{\\partial x^2} + e^{-t} (3\\frac{\\sin{2x}}{2} + \\frac{8\\sin{3x}}{3} + \\frac{15\\sin{4x}}{4} + \\frac{63\\sin{8x}}{8})\n一维空间区域为:x \\in [-\\pi, \\pi]\n时间区间为:t \\in [0, 1]\n初始条件为：y(x, 0) = \\sin{x} + \\frac{\\sin{2x}}{2} + \\frac{\\sin{3x}}{3} + \\frac{\\sin{4x}}{4} + \\frac{\\sin{8x}}{8}  \n边界条件为：y(t, -\\pi) = y(t, \\pi) = 0 \n精确解为：y(x, t) = e^{-t}( \\sin{x} + \\frac{\\sin{2x}}{2} + \\frac{\\sin{3x}}{3} + \\frac{\\sin{4x}}{4} + \\frac{\\sin{8x}}{8})\n不要使用L-BFGS优化器，训练轮数应设置多一些",
    "difficulty_level": "medium",
    "has_reference_solution": true,
    "expected_tool_chain": [
        {
            "step": "1",
            "tool_name": "define_pde",
            "parameters": {
                "equation": "\\frac{\\partial y}{\\partial t} = \\frac{\\partial^2 y}{\\partial x^2} + e^{-t} (3\\frac{\\sin{2x}}{2} + \\frac{8\\sin{3x}}{3} + \\frac{15\\sin{4x}}{4} + \\frac{63\\sin{8x}}{8})"
            },
            "return": {
                "pde": "a function object, whicn is used to define the PDE",
                "pde_code":"def pde(x, y):\n    dy_t = dde.grad.jacobian(y, x, i=0, j=1)  # first-order derivative of y with respect to t\n    dy_xx = dde.grad.hessian(y, x, i=0, j=0)  # second-order derivative of y with respect to x\n    x_val, t_val = x[:, 0:1], x[:, 1:2]\n    source_term = torch.exp(-t_val) * (\n        3 * torch.sin(2 * x_val) / 2 +\n        8 * torch.sin(3 * x_val) / 3 +\n        15 * torch.sin(4 * x_val) / 4 +\n        63 * torch.sin(8 * x_val) / 8\n    )\n    return dy_t - dy_xx - source_term"
            }
        },
        {
            "step": "2",
            "tool_name": "define_reference_solution",
            "parameters": {
                "solution": "e^{-t}( \\sin{x} + \\frac{\\sin{2x}}{2} + \\frac{\\sin{3x}}{3} + \\frac{\\sin{4x}}{4} + \\frac{\\sin{8x}}{8})"
            },
            "return": {
                "ref_func": "a function object, which is used to define the reference solution",
                "ref_code": "def ref_func(x):\n    return np.exp(-x[:, 1:2]) * (\n        np.sin(x[:, 0:1]) + \n        np.sin(2 * x[:, 0:1]) / 2 + \n        np.sin(3 * x[:, 0:1]) / 3 + \n        np.sin(4 * x[:, 0:1]) / 4 + \n        np.sin(8 * x[:, 0:1]) / 8\n    )\n"
            }
        },
        {
            "step": "3",
            "tool_name": "define_domain",
            "parameters": {
                "geom_type": "Interval",
                "geom_range": [
                    "-np.pi", "np.pi"
                ],
                "is_time_dependent": true,
                "time_range": [0,1]
            },
            "return": {
                "geomtime": "a GeometryXTime object, which is used to define the domain and time"
            }
        },
        {
            "step":"4",
            "tool_name": "define_initial_condition",
            "parameters":{
                "geomtime": "a GeometryXTime object at Step_3_1",
                "ic_description": "This is a time-dependent one-dimensional PDE problem with a spatial range of [-\\pi,\\pi], a time range of [0, 1], and an initial condition of u(x, 0) = \\sin{x} + \\frac{\\sin{2x}}{2} + \\frac{\\sin{3x}}{3} + \\frac{\\sin{4x}}{4} + \\frac{\\sin{8x}}{8}"
            },
            "return": {
                "ic":"a list of initial condition objects, which is used to define the initial condition",
                "ic_code":"def func(X):\n    x = X[:, 0:1]\n    return np.sin(x) + np.sin(2 * x) / 2 + np.sin(3 * x) / 3 + np.sin(4 * x) / 4 + np.sin(8 * x) / 8\ninitial = lambda _, on_initial: on_initial\nic1 = dde.icbc.IC(geomtime, func, initial)"
            }
        },
        {
            "step":"5",
            "tool_name": "define_boundary_condition",
            "parameters":{
                "geomtime": "a GeometryXTime object at Step_3_1",
                "bc_description": "This is a time-dependent one-dimensional PDE problem with a spatial range of [-\\pi,\\pi], a time range of [0, 1], and a boundary condition of u(-\\pi,t) = u(\\pi,t) = 0"
            },
            "return":{
                "bc":"a list of boundary condition objects, which is used to define the boundary condition",
                "bc_code":"def func(x):\n    return 0\ndef boundary_l(x, on_boundary):\n    return on_boundary and dde.utils.isclose(x[0], -np.pi)\ndef boundary_r(x, on_boundary):\n    return on_boundary and dde.utils.isclose(x[0], np.pi)\nbc1 = dde.icbc.DirichletBC(geomtime, func, boundary_l)\nbc2 = dde.icbc.DirichletBC(geomtime, func, boundary_r)"
            }
        },
        {
            "step":"6",
            "tool_name": "create_training_data",
            "parameters":{
                "geomtime": "a GeometryXTime object at Step_3_1",
                "pde_func": "a function object at Step_1_1",
                "num_domain": 1000,
                "num_boundary": 200,
                "num_initial": 200,
                "num_test": 1000,
                "bc": "a list of boundary condition objects at Step_5_1",
                "ic": "a list of initial condition objects at Step_4_1",
                "ref_func": "a function object at Step_2_1",
                "is_time_dependent": true
            },
            "return":{
                "data": "a dde.data.pde.TimePDE object, which is used to generate the training data for the model training"
            }
        },
        {
            "step":"7",
            "tool_name": "create_network",
            "parameters":{
                "input_dim": 2,
                "output_dim": 1,
                "hidden_layers": [32, 32, 32, 32, 32, 32]
            },
            "return":{
                "net": "a deepxde.nn.pytorch.fnn.FNN object, which is used to define the neural network structure"
            }
        },
        {
            "step":"8",
            "tool_name": "train_model",
            "parameters":{
                "data": "a dde.data.pde.TimePDE object at Step_5_1",
                "net": "a deepxde.nn.pytorch.fnn.FNN object at Step_6_1",
                "iterations": 20000,
                "metrics": ["l2 relative error"]
            },
            "return":{
                "model":"a deepxde.model.Model object, which includes the neural network and training data",
                "losshistory": "a deepxde.model.LossHistory object, which records the training loss and testing loss",
                "train_state": "a deepxde.model.TrainState object, which records the training state information"
            }
        },
        {
            "step":"9",
            "tool_name": "visualize_and_save",
            "parameters":{
                "loss_history": "a deepxde.model.LossHistory object at Step_8_2",
                "train_state": "a deepxde.model.TrainState object at Step_8_3",
                "is_save": true,
                "is_plot": true
            },
            "return":{
            }
        }
    ],
    "expected_results": {
        "train_loss_threshold": 1e-2,
        "test_loss_threshold": 1e-2,
        "test_metric_threshold": 2e-2
    }
}